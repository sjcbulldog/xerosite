import { Injectable, inject } from '@angular/core';
import { HttpClient, HttpEvent, HttpEventType } from '@angular/common/http';
import { firstValueFrom, Observable } from 'rxjs';
import { map } from 'rxjs/operators';

export enum MessageRecipientType {
  ALL_TEAM_MEMBERS = 'ALL_TEAM_MEMBERS',
  USER_GROUP = 'USER_GROUP',
}

export interface SendMessageRequest {
  teamId: string;
  subject: string;
  content: string;
  recipientType: MessageRecipientType;
  userGroupId?: string;
}

export interface MessageResponse {
  id: string;
  teamId: string;
  senderId: string;
  senderName: string;
  senderEmail: string;
  subject: string;
  content: string;
  recipientType: MessageRecipientType;
  userGroupId?: string;
  userGroupName?: string;
  recipientCount: number;
  attachments?: Array<{
    fileId: string;
    filename: string;
    originalName: string;
    mimetype: string;
    size: number;
  }>;
  hasUnviewedAttachments?: boolean;
  sentAt?: Date;
  errorMessage?: string;
  createdAt: Date;
  updatedAt: Date;
}

export interface GetMessagesQuery {
  startDate?: string;
  endDate?: string;
  search?: string;
}

@Injectable({
  providedIn: 'root'
})
export class MessagesService {
  private readonly http = inject(HttpClient);
  private readonly apiUrl = '/api/teams';

  async sendMessage(teamId: string, request: SendMessageRequest, files?: File[]): Promise<MessageResponse> {
    try {
      if (files && files.length > 0) {
        // Send as multipart form data with files
        const formData = new FormData();
        formData.append('subject', request.subject);
        formData.append('content', request.content);
        formData.append('recipientType', request.recipientType);
        if (request.userGroupId) {
          formData.append('userGroupId', request.userGroupId);
        }

        // Append files
        files.forEach(file => {
          formData.append('attachments', file);
        });

        return await firstValueFrom(
          this.http.post<MessageResponse>(`${this.apiUrl}/${teamId}/messages`, formData)
        );
      } else {
        // Send as JSON without files
        return await firstValueFrom(
          this.http.post<MessageResponse>(`${this.apiUrl}/${teamId}/messages`, request)
        );
      }
    } catch (error: any) {
      console.error('Error sending message:', error);
      throw new Error(error.error?.message || 'Failed to send message');
    }
  }

  /**
   * Send message with progress reporting for file uploads
   */
  sendMessageWithProgress(
    teamId: string,
    request: SendMessageRequest,
    files?: File[]
  ): Observable<{ type: 'progress' | 'response'; progress?: number; response?: MessageResponse }> {
    if (!files || files.length === 0) {
      // No files, just send normally
      return new Observable(observer => {
        this.sendMessage(teamId, request).then(
          response => {
            observer.next({ type: 'response', response });
            observer.complete();
          },
          error => observer.error(error)
        );
      });
    }

    const formData = new FormData();
    formData.append('subject', request.subject);
    formData.append('content', request.content);
    formData.append('recipientType', request.recipientType);
    if (request.userGroupId) {
      formData.append('userGroupId', request.userGroupId);
    }

    files.forEach(file => {
      formData.append('attachments', file);
    });

    return this.http.post<MessageResponse>(
      `${this.apiUrl}/${teamId}/messages`,
      formData,
      {
        reportProgress: true,
        observe: 'events'
      }
    ).pipe(
      map((event: HttpEvent<any>) => {
        if (event.type === HttpEventType.UploadProgress) {
          const progress = event.total ? Math.round((100 * event.loaded) / event.total) : 0;
          return { type: 'progress' as const, progress };
        } else if (event.type === HttpEventType.Response) {
          return { type: 'response' as const, response: event.body };
        }
        return { type: 'progress' as const, progress: 0 };
      })
    );
  }

  async getTeamMessages(teamId: string, query?: GetMessagesQuery): Promise<MessageResponse[]> {
    try {
      const params: any = {};
      if (query?.startDate) params.startDate = query.startDate;
      if (query?.endDate) params.endDate = query.endDate;
      if (query?.search) params.search = query.search;

      return await firstValueFrom(
        this.http.get<MessageResponse[]>(`${this.apiUrl}/${teamId}/messages`, { params })
      );
    } catch (error: any) {
      console.error('Error getting team messages:', error);
      throw new Error(error.error?.message || 'Failed to get team messages');
    }
  }
}